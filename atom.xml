<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-13T07:28:49.891Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 构建脚本从 Groovy 迁移到 Kotlin DSL</title>
    <link href="http://yoursite.com/2019/02/01/Android%20%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E4%BB%8EGroovy%E8%BF%81%E7%A7%BB%E5%88%B0Kotlin%20DSL/"/>
    <id>http://yoursite.com/2019/02/01/Android 构建脚本从Groovy迁移到Kotlin DSL/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-02-13T07:28:49.891Z</updated>
    
    <content type="html"><![CDATA[<p>网上已经有不少关于 Kotlin-DSL 很好的文章，但并未能完全解答我迁移过程中遇到的疑问。通过查阅各类文档和源码，我找到了想要的答案。这篇文章记录了我的迁移过程以及对各类问题追溯到源头的答案。</p><h1 id="为什么要迁移？"><a href="#为什么要迁移？" class="headerlink" title="为什么要迁移？"></a>为什么要迁移？</h1><p>因为 Groovy 是动态语言，在用作 Android 构建脚本的时候，经常有些问题：</p><ul><li>很差的IDE支持(自动提示等)</li><li>性能问题</li><li>很多错误在<code>build</code>时才报出，而不是编译期</li><li>难以debug</li><li>重构很麻烦<br><br>…</li></ul><p>kotlin 并非动态语言，但却兼具了 Groovy 的灵活性和静态语言的特点，是一种类型安全的 DSL，很大程度上解决了上述的问题。</p><p>所以，开始吧！！<br><a id="more"></a></p><h2 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h2><ul><li><p>升级 Gradle Wrapper 到5.0+</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># gradle-wrapper.properties</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-5.1-all.zip</span><br></pre></td></tr></table></figure></li><li><p>Gradle 5.0 只支持Java 8及以上，确保你的Java环境满足要求</p></li><li>升级所有的Gradle 插件</li></ul><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>由于Groovy和kotlin语言特性上的不同，我们迁移时需要遵循以下基本原则。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Groovy 中字符串单双引号都行，但是kotlin中字符串必须是双引号。所以<strong>第一步先把所有的<code>build.gradle</code>和<code>settings.gradle</code>里的<code>&#39;&#39;</code>全部替换为<code>&quot;&quot;</code></strong></p><h3 id="赋值-传值"><a href="#赋值-传值" class="headerlink" title="赋值/传值"></a>赋值/传值</h3><p>在Groovy中<code>xx yy</code>可以表示对变量<code>xx</code>赋与值<code>yy</code>，也可以表示调用函数<code>xx</code>，<code>yy</code>是参数，如Android中常见的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123; </span><br><span class="line">  // 赋值</span><br><span class="line">  versionName &quot;1.0&quot;</span><br><span class="line">  // 函数调用</span><br><span class="line">  minSdkVersion 16 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // 函数调用</span><br><span class="line">    api &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在kotlin中则是和Java一样的语法，相应的，上面的栗子迁移后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    versionName = &quot;1.0&quot;</span><br><span class="line">    minSdkVersion(16)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api(&quot;org.greenrobot:eventbus:3.1.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>知道了这个区别，但是很多<code>xx yy</code> 到底是赋值还是函数调用不好分辨，比如<code>versionName &quot;1.0&quot;</code> 是赋值，而<code>minSdkVersion 16</code>居然是函数调用。我们可以利用Android Studio的辅助功能，在kotlin-dsl 中是可以快速点选查看方法的源码的（mac 下 <code>cmd + click</code>）,而对属性变量就没啥反应，所以可以根据这个小trick来分辨。</p></blockquote><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><p>由于Koltin 是静态类型语言，Groovy是动态语言，前者是类型安全的，他们的性质区别很明显的体现在了 task 的创建和配置上。详情可以参考<a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#configuring-tasks" target="_blank" rel="noopener">Gradle官方迁移教程</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// groovy</span><br><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line">// kotiln-dsl</span><br><span class="line">tasks.register(&quot;clean&quot;, Delete::class) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h1><ol><li>字符串单引号变双引号</li><li>重命名所有<code>xx.gradle</code>脚本文件，加上<code>.kts</code>后缀</li><li><p>插件声明</p><p> DSL的目标是尽可能具有声明性。 Kotlin DSL 使用<code>plugins</code>代码块来生成静态扩展函数以利用这些插件。因此，我们需要将之前Groovy中所有<code>apply plugin xxx</code> 移动到一个<code>plugins</code>代码块中：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Groovy</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line">apply plugin: &apos;kotlin-kapt&apos;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin-dsl</span><br><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;com.android.application&quot;)</span><br><span class="line">    kotlin(&quot;android&quot;)</span><br><span class="line">    kotlin(&quot;android.extensions&quot;)</span><br><span class="line">    kotlin(&quot;kapt&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>id()</code>是应用插件的标准方法，<code>kotlin()</code>是应用<code>Kotlin</code>插件的方法，我们查看源码可以发现，它只是封装了一下<code>id()</code>方法，省略了<code>org.jetbrains.kotlin.</code>:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun PluginDependenciesSpec.kotlin(module: String): PluginDependencySpec =</span><br><span class="line">   id(&quot;org.jetbrains.kotlin.$module&quot;)</span><br></pre></td></tr></table></figure></li><li><p>按前面提到的<a href="#基本原则">基本原则</a>改写所有语句</p></li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>除了apple 插件外，apply 还可以用来应用其他的<code>gradle</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//groovy</span><br><span class="line">apply from: &apos;custom.gradle&apos;</span><br><span class="line"></span><br><span class="line">// kotlin-dsl</span><br><span class="line">apply(from = &quot;custom.gradle&quot;)</span><br></pre></td></tr></table></figure></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖管理作为 gradle 的基本功能，gradle 提供了非常丰富的方法，下面以分三种情形进行说明。</p><h3 id="基本情形"><a href="#基本情形" class="headerlink" title="基本情形"></a>基本情形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// groovy</span><br><span class="line">implementation project(&apos;:library&apos;)</span><br><span class="line">implementation &apos;com.jakewharton:butterknife:8.8.1&apos;</span><br><span class="line"></span><br><span class="line">// kotlin</span><br><span class="line">implementation(project(&quot;:library&quot;))</span><br><span class="line">implementation(&quot;com.jakewharton:butterknife:8.8.1&quot;)</span><br></pre></td></tr></table></figure><h3 id="fileTree"><a href="#fileTree" class="headerlink" title="fileTree"></a>fileTree</h3><p>使用 groovy 添加本地目录 jar 包依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// groovy</span><br><span class="line">implementation fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)</span><br></pre></td></tr></table></figure></p><p>查看 fileTree 函数源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//org.gradle.api.Project</span><br><span class="line">ConfigurableFileTree fileTree(Map&lt;String, ?&gt; args);</span><br></pre></td></tr></table></figure></p><p>需要传入的是<code>Map</code>，因此迁移到 kotlin-dsl 可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(fileTree(mapOf(&quot;include&quot; to listOf(&quot;*.jar&quot;), &quot;dir&quot; to &quot;libs&quot;)))</span><br></pre></td></tr></table></figure></p><h3 id="特别类型库依赖"><a href="#特别类型库依赖" class="headerlink" title="特别类型库依赖"></a>特别类型库依赖</h3><p>之前在<code>groovy</code>中添加特别类型库依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(name: &apos;splibrary&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure></p><p>按前面提到的基本原则，我们会这样改写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// wrong</span><br><span class="line">implementation (name=&quot;splibrary&quot;,ext = &quot;aar&quot;)</span><br></pre></td></tr></table></figure></p><p>但实际上会导致失败。跳转到 kotlin-dsl <code>implementation</code>的源码找原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun DependencyHandler.`implementation`(dependencyNotation: Any)...</span><br><span class="line"></span><br><span class="line">fun DependencyHandler.`implementation`(</span><br><span class="line">    dependencyNotation: String,</span><br><span class="line">    dependencyConfiguration: Action&lt;ExternalModuleDependency&gt;</span><br><span class="line">)...</span><br><span class="line"></span><br><span class="line">fun DependencyHandler.`implementation`(</span><br><span class="line">    group: String,</span><br><span class="line">    name: String,</span><br><span class="line">    version: String? = null,</span><br><span class="line">    configuration: String? = null,</span><br><span class="line">    classifier: String? = null,</span><br><span class="line">    ext: String? = null,</span><br><span class="line">    dependencyConfiguration: Action&lt;ExternalModuleDependency&gt;? = null</span><br><span class="line">)...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可以看到<code>implementation</code>有许多重载方法，可以用来处理各种依赖来源及设置的条件。在第三种实现对应的是我们的情况，其中<code>group</code>参数是必填的。</p><p>因此在<code>kotlin-dsl</code>中需要这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation (group=&quot;&quot;,name=&quot;splibrary&quot;,ext = &quot;aar&quot;)</span><br></pre></td></tr></table></figure></p><p>必须加一个<code>group</code>还是很奇怪的，而目前看来这是一个bug (<a href="https://github.com/gradle/kotlin-dsl/issues/863" target="_blank" rel="noopener">Gitub issue</a>)</p><h2 id="build-variants"><a href="#build-variants" class="headerlink" title="build variants"></a>build variants</h2><p>构建变体代表我们可以为应用构建的一个不同版本，比如“全功能release版”，”全功能”就是一种 productFlavor, “release” 则是一种 buildType，通过自定义并组合多种 productFlavor 和 buildType 可以构建多种不同版本的应用。</p><p>在 Groovy 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">        demo &#123;</span><br><span class="line">            dimension &quot;app&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        full &#123;</span><br><span class="line">            dimension &quot;app&quot;</span><br><span class="line">            multiDexEnabled true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            signingConfig signingConfigs.signConfig</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            debuggable false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            debuggable true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile file(&quot;myreleasekey.keystore&quot;)</span><br><span class="line">            storePassword &quot;password&quot;</span><br><span class="line">            keyAlias &quot;MyReleaseKey&quot;</span><br><span class="line">            keyPassword &quot;password&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在 kotlin-dsl 中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    create(&quot;demo&quot;) &#123;</span><br><span class="line">        dimension = &quot;app&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    create(&quot;full&quot;) &#123;</span><br><span class="line">        dimension = &quot;app&quot;</span><br><span class="line">        multiDexEnabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildTypes &#123;</span><br><span class="line">        getByName(&quot;release&quot;) &#123;</span><br><span class="line">            signingConfig = signingConfigs.getByName(&quot;release&quot;)</span><br><span class="line">            isMinifyEnabled = true</span><br><span class="line">            isDebuggable = false</span><br><span class="line">            proguardFiles(getDefaultProguardFile(&quot;proguard-android.txtt&quot;), &quot;proguard-rules.pro&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        getByName(&quot;debug&quot;) &#123;</span><br><span class="line">            isMinifyEnabled = false</span><br><span class="line">            isDebuggable = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">signingConfigs &#123;</span><br><span class="line">        create(&quot;release&quot;) &#123;</span><br><span class="line">            storeFile = file(&quot;myreleasekey.keystore&quot;)</span><br><span class="line">            storePassword = &quot;password&quot;</span><br><span class="line">            keyAlias = &quot;MyReleaseKey&quot;</span><br><span class="line">            keyPassword = &quot;password&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        getByName(&quot;debug&quot;) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>说明：</p><ol><li><p><code>create()</code> 和 <code>getByName()</code>是哪儿来的？<code>demo</code>,<code>full</code>,<code>release</code>等为什么作为字符串变成函数的参数了？</p><p> 在Groovy中，<code>buildTypes</code> 和 <code>productFlavors</code> 以及 <code>signingConfigs</code> 这几个函数都接收一个<code>Action&lt;? super NamedDomainObjectContainer&lt;T&gt;&gt;</code> 的接口作为参数，<code>Action</code> 是一个函数式接口，其唯一的方法接收一个 <code>NamedDomainObjectContainer</code>接口的实现类对象作为参数，而这个接口的主要方法就包含了 <code>create()</code> 和 <code>getByName()</code>，这俩方法有一些重载方法，但都包含一个字符串参数作为 <code>T</code> 的对象标识<code>name</code>。在 Groovy 中的<code>full</code>,<code>release</code>等值都会作为这个参数的值传入。</p><p> 以<code>signingConfigs</code>为例，用 Java 代码来演示可以更详细的展示这个调用层级：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs(signingConfigContainer -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    signingConfigContainer.create(<span class="string">"release"</span>,signingConfig -&gt;&#123;</span><br><span class="line">        signingConfig.setStorePassword(<span class="string">"xxxx"</span>);</span><br><span class="line">        signingConfig.setKeyAlias(<span class="string">"xx.yy.zz"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> *<code>signingConfigContainer</code> 就是接口 <code>NamedDomainObjectContainer&lt;SigningConfig&gt;</code>的实现类。</p></li><li><p><code>create()</code> 和 <code>getByName()</code> 在什么时候使用？</p><p> 在<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/NamedDomainObjectContainer.html" target="_blank" rel="noopener"><code>NamedDomainObjectContainer</code></a>和其子接口<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/NamedDomainObjectCollection.html" target="_blank" rel="noopener"><code>NamedDomainObjectCollection</code></a>的Api 文档中已详细说明，简而言之，当其中的元素(i.e.productFlavor/buildType)已经存在则调用<code>getByName()</code>，否则使用<code>create()</code>创建新对象。</p><p> 而<code>buildTypes</code>中的<code>debug</code>和<code>release</code>以及 signingConfigs 中的<code>debug</code>都是默认存在的，通过查看<a href="https://android.googlesource.com/platform/tools/build/+/refs/tags/android-7.1.0_r1/gradle/src/main/groovy/com/android/build/gradle/AppPlugin.groovy#113" target="_blank" rel="noopener">Android Gradle插件的源码</a>可以发现这一点：</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.android.build.gradle.AppPlugin</span></span><br><span class="line"> </span><br><span class="line">signingConfigContainer.create(DEBUG)</span><br><span class="line">buildTypeContainer.create(DEBUG)</span><br><span class="line">buildTypeContainer.create(RELEASE)</span><br></pre></td></tr></table></figure><p> 因此这三者是调用<code>getByName()</code>方法进行配置的。</p></li><li><p>在属性配置的代码块中，boolean 类型的赋值为什么有的在原来的表示（指 Groovy 中的表示）前加了is (e.g. minifyEnabled)，有的不加 (e.g. multiDexEnabled)？</p><p> 这其实就是 kotlin 和 java 的<a href="https://kotlinlang.org/docs/reference/java-interop.html#getters-and-setters" target="_blank" rel="noopener">互调用规则</a>决定的。 我们进行属性配置的这些类，即 SigningConfig BuildType 等，其源码都是 Java。</p><p> 从 kotlin 中调用 Java，遵循 getterter 和 setter 的 Java 约定的方法（名称以 <code>get</code>开头的无参数方法和名称以<code>set</code>开头的单参数方法）在 Kotlin 中表示为属性，对boolean类型属性有两种情况：</p><ol><li><p>当 Java 类中的某boolean类型属性的<code>getter/setter</code>方法形如<code>setXxx()</code> <code>isXxx()</code>的时候，kotlin进行取值或赋值调用都是<code>isXxx</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(!isXxx)&#123;</span><br><span class="line">    isXxx = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>形如通常的<code>getXxx()</code>和<code>setXxx()</code>的时候，kotlin的调用则不带前缀<code>is</code>。<br>跳转到<code>BuildType</code>等的源码可以发现，<code>minifyEnabled</code> 属于第一种情况，而<code>multiDexEnabled</code>属于第二种情况，因此转为<code>kotlin</code>时前者需要带前缀<code>is</code>。</p></li></ol></li></ol><h2 id="访问gradle-properties中的配置"><a href="#访问gradle-properties中的配置" class="headerlink" title="访问gradle.properties中的配置"></a>访问<code>gradle.properties</code>中的配置</h2><p>我们通常会把签名信息、版本信息等配置写在<code>gradle.properties</code>中，<code>groovy</code>访问的时候直接引用即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># gradle.properties</span><br><span class="line"></span><br><span class="line">version_code=1</span><br><span class="line">version_name=1</span><br><span class="line"></span><br><span class="line"># build.gradle</span><br><span class="line">versionCode Integer.parseInt(version_code)</span><br><span class="line">versionName version_name</span><br></pre></td></tr></table></figure></p><p>而在kotlin-dsl的早期版本 (<a href="https://github.com/gradle/kotlin-dsl/releases/tag/v0.16.3" target="_blank" rel="noopener">v0.16.3, Gradle 4.7 之前</a>) 却无法直接访问，现在可以通过委托属性来访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># build.gradle.kts</span><br><span class="line"></span><br><span class="line">val version_code: String by project</span><br><span class="line">val version_name: String by project</span><br><span class="line">...</span><br><span class="line">versionCode = Integer.parseInt(version_code)</span><br><span class="line">versionName = version_name</span><br></pre></td></tr></table></figure></p><h2 id="关于-ext"><a href="#关于-ext" class="headerlink" title="关于 ext"></a>关于 ext</h2><p>Google 官方推荐的一个 Gradle 配置<a href="https://developer.android.com/studio/build/gradle-tips?hl=zh-cn#configure-project-wide-properties" target="_blank" rel="noopener">最佳实践</a>是在项目最外层 build.gradle 文件的<code>ext</code>代码块中定义项目范围的属性，然后在所有模块间共享这些属性，比如我们通常会这样存放依赖的版本号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// build.gradle</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = 28</span><br><span class="line">    buildToolsVersion = &quot;28.0.3&quot;</span><br><span class="line"></span><br><span class="line">    supportLibVersion = &quot;28.0.0&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是由于缺乏IDE的辅助(跳转查看、全局重构等都不支持)，实际使用体验欠佳。</p><p>随着 Gradle 5.0的发布，<a href="https://docs.gradle.org/5.0/userguide/organizing_gradle_projects.html#sec:build_sources" target="_blank" rel="noopener">Gradle官方现在推荐</a>将这些内容声明在一个专用文件夹buildSrc中。App目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app</span><br><span class="line">    ├── build.gradle.kts</span><br><span class="line">    └── src</span><br><span class="line">        ├── main</span><br><span class="line">        └── test</span><br><span class="line">├── build.gradle.kts</span><br><span class="line">├── buildSrc</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── kotlin</span><br><span class="line">            ├── Depends.kt</span><br><span class="line">            └── Versions.kt</span><br><span class="line">├── build.gradle.kts</span><br><span class="line"> ...</span><br><span class="line">└── settings.gradle</span><br></pre></td></tr></table></figure><p>依赖和版本号等值存放在了<code>Depends.kt</code>和<code>Versions.kt</code>文件中。</p><p>具体操作可以参考 <a href="https://caster.io/instructors/sam-edwards" target="_blank" rel="noopener">Sam Edwards</a> 的<a href="https://caster.io/lessons/gradle-dependency-management-using-kotlin-and-buildsrc-for-buildgradle-autocomplete-in-android-studio" target="_blank" rel="noopener">视频教程</a>，以及 DroidKaigi  的2018开发者大会的 <a href="https://github.com/DroidKaigi/conference-app-2018/blob/master/buildSrc/src/main/kotlin/Depends.kt" target="_blank" rel="noopener">App 源码</a></p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>如文章开头所述，Kotiln-dsl 是一种更友好的 DSL语言，它是类型安全的，具有完善的IDE辅助支持（代码自动提示补全，快速跳转等），语法也非常灵活，同时也有很好的可读性，虽然目前与Groovy的兼容还没有100%完成，但对功能基本没有什么影响。</p><p>但目前的kotlin-dsl也有一些问题，如 <a href="https://proandroiddev.com/migrating-android-build-scripts-from-groovy-to-kotlin-dsl-f8db79dd6737" target="_blank" rel="noopener">ProAndroidDev 的文章</a>中提到的，因为额外的类型安全检查，kotlin-dsl在性能上会有所损失，大型项目在迁移之前做个性能测试会更稳妥。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.jianshu.com/p/1e13a5fb0cbc" target="_blank" rel="noopener">Android Gradle Kotlin DSL 迁移</a></li><li><a href="http://groovy-lang.org/syntax.html#all-strings" target="_blank" rel="noopener">Apache Groovy - 字符串表示</a></li><li><a href="https://proandroiddev.com/migrating-android-build-scripts-from-groovy-to-kotlin-dsl-f8db79dd6737" target="_blank" rel="noopener">ProAndroidDev - Migrating Android build scripts from Groovy to Kotlin DSL</a></li><li><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#summary" target="_blank" rel="noopener">Gradle Guides - Migrating build logic from Groovy to Kotlin</a></li><li><a href="https://docs.gradle.org/5.2.1/userguide/organizing_gradle_projects.html" target="_blank" rel="noopener">Gradle Docs - Organizing Gradle Projects </a></li><li><a href="https://kotlinlang.org/docs/reference/type-safe-builders.html" target="_blank" rel="noopener">kotlin - Type-Safe Builders</a></li><li><a href="https://github.com/gradle/kotlin-dsl/issues/635" target="_blank" rel="noopener">kotlin-dsl Github issues - accessing gradle properties</a></li><li><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples" target="_blank" rel="noopener">kotlin-dsl samples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上已经有不少关于 Kotlin-DSL 很好的文章，但并未能完全解答我迁移过程中遇到的疑问。通过查阅各类文档和源码，我找到了想要的答案。这篇文章记录了我的迁移过程以及对各类问题追溯到源头的答案。&lt;/p&gt;
&lt;h1 id=&quot;为什么要迁移？&quot;&gt;&lt;a href=&quot;#为什么要迁移？&quot; class=&quot;headerlink&quot; title=&quot;为什么要迁移？&quot;&gt;&lt;/a&gt;为什么要迁移？&lt;/h1&gt;&lt;p&gt;因为 Groovy 是动态语言，在用作 Android 构建脚本的时候，经常有些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很差的IDE支持(自动提示等)&lt;/li&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;很多错误在&lt;code&gt;build&lt;/code&gt;时才报出，而不是编译期&lt;/li&gt;
&lt;li&gt;难以debug&lt;/li&gt;
&lt;li&gt;重构很麻烦&lt;br&gt;&lt;br&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kotlin 并非动态语言，但却兼具了 Groovy 的灵活性和静态语言的特点，是一种类型安全的 DSL，很大程度上解决了上述的问题。&lt;/p&gt;
&lt;p&gt;所以，开始吧！！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Python IO - 输出重定向</title>
    <link href="http://yoursite.com/2018/12/12/Python%20IO%20-%20%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2018/12/12/Python IO - 输出重定向/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2019-02-14T08:29:45.964Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写 Python 单元测试的时候需要获取到待测试方法的<code>print()</code>输出，在<code>Shell</code>中使用管道重定向输出很容易，但是在<code>Python</code>中如何进行呢？</p><a id="more"></a><h1 id="Python-中的标准输入输出"><a href="#Python-中的标准输入输出" class="headerlink" title="Python 中的标准输入输出"></a>Python 中的标准输入输出</h1><h2 id="print-和-sys-stdout"><a href="#print-和-sys-stdout" class="headerlink" title="print 和 sys.stdout"></a>print 和 sys.stdout</h2><p>当我们在 Python 中打印值调用 <code>print(value)</code> 时候，等价于调用 <code>sys.stdout.write(value+&#39;\n&#39;)</code></p><p>print 将内容打印到了控制台，然后追加了一个换行符</p><h2 id="input-和-sys-stdin"><a href="#input-和-sys-stdin" class="headerlink" title="input 和 sys.stdin"></a>input 和 sys.stdin</h2><p>当我们用 raw_input(‘promption: ‘) 时，事实上是先把提示信息输出，然后捕获输入</p><p>以下两组在实际上等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hi=raw_input(&apos;Hi~&apos;)</span><br><span class="line"></span><br><span class="line">sys.stdout.write(&apos;Hi~&apos;)</span><br><span class="line"># -1 to discard the &apos;\n&apos; in input stream</span><br><span class="line">hi=sys.stdin.readline()[:-1]</span><br></pre></td></tr></table></figure></p><p>而在Python 3中新增的<code>input()</code>函数则在此基础上，增加了类型判断的处理，尝试将输入解析为适当的数据类型。</p><blockquote><p>实际上 print 或者 raw_input 在 cpython 中的源码要复杂得多，这里‘等价’的仅是示意其与标准输入输出直接相关。源码可以参考文末给出的链接</p></blockquote><h1 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h1><p>默认的 <code>sys.stdout</code> 指向控制台，我们可以重定向到其他流(或者具有<code>write</code>方法的对象)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#标准输出重定向至文件</span><br><span class="line">with open(&apos;out.txt&apos;, &apos;w+&apos;) as f:</span><br><span class="line">    sys.stdout = f </span><br><span class="line"></span><br><span class="line"># 标准输出重定向至字符流</span><br><span class="line">sys.stdout = strout = StringIO()</span><br></pre></td></tr></table></figure></p><p>完成任务后最好恢复标准输出至原先的地址(默认控制台)：</p><ul><li><p>可以在重定向前获取<code>stdout</code>的默认引用，恢复的时候再指向这个引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">orig_stdout = sys.stdout</span><br><span class="line"># ...$重定向代码$...</span><br><span class="line"># ...print(&apos;hahaha...&apos;)...</span><br><span class="line"></span><br><span class="line"># 恢复</span><br><span class="line">sys.stdout = orig_stdout</span><br></pre></td></tr></table></figure></li><li><p>或使用<code>sys.__stdout__</code>，其保存程序开始时<code>sys.stdout</code>的原始值，且不受重定向影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ...$重定向代码$...</span><br><span class="line"># ...print(&apos;hahaha...&apos;)...</span><br><span class="line">sys.stdout = sys.__stdout__</span><br></pre></td></tr></table></figure></li></ul><p>结合上下文管理器，我们还可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def stdout_redirected(new_stdout):</span><br><span class="line">    save_stdout = sys.stdout</span><br><span class="line">    sys.stdout = new_stdout</span><br><span class="line">    try:</span><br><span class="line">        yield None</span><br><span class="line">    finally:</span><br><span class="line">        sys.stdout = save_stdout</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">with opened(filename, &quot;w&quot;) as f:</span><br><span class="line">    with stdout_redirected(f):</span><br><span class="line">        print &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p><p>应用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from io import StringIO</span><br><span class="line"></span><br><span class="line"># parse 函数直接将&apos;解析&apos;结果打印出来了，我们需要判断解析是否正确</span><br><span class="line"></span><br><span class="line">def parse(query):</span><br><span class="line">    print(f&apos;query: &#123;query&#125;&apos;)</span><br><span class="line"></span><br><span class="line">def test(query):</span><br><span class="line">    sys.stdout = strdout = StringIO()</span><br><span class="line">    parse(query)</span><br><span class="line">    sys.stdout = sys.__stdout__</span><br><span class="line">    return strdout.getvalue()</span><br><span class="line"></span><br><span class="line">result = test(&apos;This message is for query&apos;)</span><br><span class="line">print(result.split()[1])</span><br><span class="line"></span><br><span class="line"># output：This</span><br></pre></td></tr></table></figure></p><p>同样的，<code>sys.stderr</code>, <code>sys.stdin</code> 也都可以被重定向到多个地址。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/python/cpython/blob/3.6/Python/sysmodule.c" target="_blank" rel="noopener">cpython 3.6 - sys</a></li><li><a href="https://github.com/python/cpython/blob/c41523ac2447b0e86b702f58458f3b3548439c8b/Python/bltinmodule.c#L1864" target="_blank" rel="noopener">cpython 3.6 - input</a></li><li><a href="https://docs.python.org/3/library/sys.html#sys.__stdout__" target="_blank" rel="noopener">python 3 doc - sys.__stdout__</a></li><li><a href="https://www.python.org/dev/peps/pep-0343/#use-cases" target="_blank" rel="noopener">PEP 343 – The “with” Statement use-case</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写 Python 单元测试的时候需要获取到待测试方法的&lt;code&gt;print()&lt;/code&gt;输出，在&lt;code&gt;Shell&lt;/code&gt;中使用管道重定向输出很容易，但是在&lt;code&gt;Python&lt;/code&gt;中如何进行呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="io" scheme="http://yoursite.com/categories/Python/io/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android 蓝牙开发 ᚼᛒ (一)</title>
    <link href="http://yoursite.com/2018/08/18/Android%20%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91%20%E1%9A%BC%E1%9B%92%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/18/Android 蓝牙开发 ᚼᛒ（一）/</id>
    <published>2018-08-17T16:00:00.000Z</published>
    <updated>2019-02-25T16:22:29.873Z</updated>
    
    <content type="html"><![CDATA[<p>接触 Android 蓝牙开发已经有一段时间了，Android 官方文档虽然对蓝牙 API 介绍很详尽，但是对蓝牙协议不太了解的开发人员来说还是不足以建立一个系统的认识，当时和硬件组的小伙伴交流的时候这点带来的问题就特别明显。网上的资料少，并且良莠不齐，于是去 SIG 官网找了协议文档（七大卷，真的厚…)，查阅之后，厘清了很多概念，大致了解了整个系统轮廓。</p><p>接下来会从蓝牙协议和 Android 蓝牙开发这两部分来叙述。</p><p>这是第一篇，蓝牙协议。</p><h2 id="什么是蓝牙"><a href="#什么是蓝牙" class="headerlink" title="什么是蓝牙"></a>什么是蓝牙</h2><p>蓝牙是一种短距离的短波无线通信技术，目前主要分为<strong>基础率/增强数据率（BR / EDR</strong>）和<strong>低功耗（LE）</strong>两个版本，前者通常也称为<strong>经典版蓝牙</strong>。</p><p>关于蓝牙这个名称的由来，蓝牙的发展历史及各版本的比对等基本信息在<a href="https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99" target="_blank" rel="noopener">蓝牙的维基百科词条</a>上写得很详细，就不再赘述。</p><h2 id="蓝牙的架构"><a href="#蓝牙的架构" class="headerlink" title="蓝牙的架构"></a>蓝牙的架构</h2><p>蓝牙4.0是一个综合协议规范，它除了提出了新的 LE 规范，还囊括了 BR / EDR 规范，并在实际使用中分为了单模(Single mode)和双模(Dual mode)版本，前者仅支持 LE 规范且不能和蓝牙4.0之前的版本通信，后者同时支持 LE 和 BR / EDR 规范，并且兼容旧版蓝牙。</p><blockquote><p>本文关于蓝牙协议栈的分析均基于蓝牙4.1</p></blockquote><p>下图是根据蓝牙 4.1 核心技术栈及部分应用协议绘制的蓝牙协议栈示意图<br><img src="https://docs.google.com/drawings/d/e/2PACX-1vSPsBu4C99TXGRhrGDNB-XbGeaFb76966Zol_ZcCwRI0QUSI19fwi0GMbcLHMDLEMwKuBAXVUBtY3bP/pub?w=542&amp;h=510" alt="蓝牙协议栈"><br>*<em>上图仅供参考，详细架构图参见 <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=282159" target="_blank" rel="noopener">SIG 蓝牙协议文档</a></em><br><a id="more"></a></p><p>蓝牙协议栈主要由主机 (Host)、控制器(Controllers) 和主机控制器接口(Host Controller Interface, HCI) 三部分组成。</p><p>我们先以两个直观的表述来感受这三部分与我们现实设备的对应关系。</p><p><em>对于没有蓝牙的PC，我们通常可以淘宝买一个USB蓝牙适配器来为PC增加蓝牙功能</em>。这里的蓝牙适配器可以理解为Controllers，PC 可以理解为 Host，USB 的连接方式就是一种 HCI。</p><p>我们的手机上的蓝牙模块也可以这样对应，手机操作系统就是Host，Controllers就是主板上的蓝牙芯片，PCB 板上连接 CPU 和蓝牙 IC 的 <a href="https://zh.wikipedia.org/wiki/UART" target="_blank" rel="noopener">UART</a>，也是一种HCI。</p><p>当然，以上表述并不严谨，实际上 Host 层是硬件的抽象，而与具体的硬件无关，控制器是协议栈的底层实现，它才与硬件直接相关，通常就是蓝牙 IC。</p><p>前文图中展示的仅是一个通用的蓝牙架构图，我们手机上的双模蓝牙系统与之类似，但实际上<strong>一个蓝牙设备可以仅由一个 Host 和一个主控制器组成</strong>，HCI 层其实是可选的，在具有简单功能的蓝牙设备（例如耳机）中，Host 和控制器可以在同一微处理器上实现, 而无需 HCI。</p><p>主控制器可以是以下三种：</p><ul><li>BR / EDR 控制器</li><li>LE 控制器</li><li>BR / EDR 和 LE 组合控制器</li></ul><p>可选的还可以有一个或多个次要控制器(AMP)，AMP 在蓝牙 3.0 就已经引入，主要和 BR / EDR 搭配使用，作为数据高速传输通道。这种场景下，BR / EDR 主要用作搜索，配对，连接建立和连接维持的作用。当两个 BR / EDR 蓝牙设备 L2CAP 连接建立后，AMP 管理器能检测到另外一个设备的AMP管理器。当两个蓝牙设备都有 AMP 控制器，蓝牙核心系统提供这样一种机制，能让数据流从主控制器迁移到次要控制器，即通过 AMP 来传输，AMP 可以使用 <a href="https://zh.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">802.11</a> 协议转换层(PAL) 來提供更高的傳輸率，最高可达 54 Mbps。</p><p>结合以上，关于实际的蓝牙设备架构，我们可以组合几种控制器和 Host 得到以下符合规范的蓝牙架构：</p><ul><li>四种可能的单模架构</li></ul><p><img src="/images/single_arch.png" alt="single"></p><ul><li>三种可能的双模架构</li></ul><p><img src="/images/dual_arch.png" alt="dual"></p><p>控制器和 HCI 涉及底层硬件部分，不做更多讨论，接下来重点对 Host 层做一个具体的说明。</p><h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><p>Host 包含逻辑链路控制和适配层(Logical Link control &amp; Adaption Protocol, L2CAP) 以及图中未画出的 Channel Manager、Security Manager Protocol (SMP) 和图中出现的 GAP等其他更高层。L2CAP主要起到数据缓冲和简单数据管理的作用。通道管理器负责创建，管理和关闭用于传输服务协议和应用程序数据流的L2CAP通道。SMP等其他部分详情参见核心协议文档，我们把重点放到应用层。</p><h3 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h3><p>蓝牙系统中的应用程序互操作性（应用部分）由各种蓝牙配置文件（Profile）完成。</p><p> <strong>Profile 就是定义了一个实际的应用场景</strong>。具体来说，Profile 定义了蓝牙系统中从PHY（物理层）到 L2CAP 的每层以及核心规范之外的任何其他协议所需的功能和特性。应用的行为和数据格式也由 Profile 定义。当两个蓝牙设备都符合某一种配置文件 的所有要求时，即可开启并执行对应的应用操作。需要特别说明的是，LE 的Profile 和 BR / EDR 的并不兼容，前文中的蓝牙架构图里展示出的几个Profile例子中，<strong>蓝色背景的是 BR / EDR 特有的Profile</strong>。</p><p>蓝牙规范中定义了很多常用的 Profile，在 4.0 中引入的 GATT / ATT 让我们可以创建新的 Profile。 下面介绍一些常用的配置文件</p><h4 id="GAP"><a href="#GAP" class="headerlink" title="GAP"></a>GAP</h4><p><strong>GAP，即通用访问配置文件，所有蓝牙设备都必须实现的基本配置文件。</strong> 它定义了蓝牙设备的基本要求，例如，对于 BR / EDR，它定义了蓝牙设备以包括无线电，基带，链路管理器，L2CAP 和服务发现协议功能; 对于 LE，它定义了物理层，链路层，L2CAP，安全管理器，GATT / ATT。这将所有各层连接在一起，形成蓝牙设备的基本要求。它还描述了设备搜寻，连接建立，安全性，身份验证，关联模型和服务搜寻的行为方法。</p><ul><li><p>在BR / EDR中，GAP定义每个设备为单一角色，其可能具备的功能包括设备如何相互发现，建立连接以及描述用于身份验证的安全关联模型。设备可能只具备其中一种或多种功能，比如只具有启动或接受连接功能。</p></li><li><p>在 LE 中，GAP 定义了四个特定角色：<strong>Broadcaster</strong>，<strong>Observer</strong>，<strong>Peripheral</strong> 和 <strong>Central</strong>。如果底层 Controller 支持这些角色或角色组合，则设备也可同时支持多个角色。但是，在某一时刻只能支持其中一个角色。每个角色都指定了底层Controller的要求。这允许控制器针对特定用例进行优化。</p></li></ul><h4 id="LE-的-Profiles"><a href="#LE-的-Profiles" class="headerlink" title="LE 的 Profiles"></a>LE 的 Profiles</h4><p>如上所诉，LE 让我们可以创建自己的 Profile，当然需要遵循一定的规范，这个规范就是 GATT / ATT</p><h5 id="GATT-ATT"><a href="#GATT-ATT" class="headerlink" title="GATT / ATT"></a>GATT / ATT</h5><p>通用属性配置文件（GATT）构建在属性协议（ATT）之上，并为属性协议传输和存储的数据建立通用操作和框架。GATT 和 ATT 通常在 LE 中实现。</p><blockquote><p>是的，GATT 和 ATT 还可以在 BR / EDR 中实现，蓝牙 4.1 核心系统协议中对 GATT / ATT 的表述是：<em>“GATT和ATT不是特定于传输层的，其可用于BR / EDR 和 LE。而在 LE 中 GATT / ATT 用于搜寻服务，因此是必须实现的”</em> (<em>from</em> <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=282159" target="_blank" rel="noopener">core_SPEC_vol1_6.4</a>)</p></blockquote><p>GATT 定义了两个角色：服务端和客户端。 GATT 角色不一定与特定的 LE GAP 角色相关联，但可以由更高层的配置文件指定。GATT 服务器发送对请求的响应，并在配置时，在GATT服务器上发生指定事件时，向GATT客户端异步发送指示和通知。</p><p>GATT 按照层级定义了三个概念：服务（Service）、特征（Characteristic）和描述（Descriptor）。他们的包含关系如下图所示：一个 Service 包含若干个 Characteristic，一个 Characteristic 包含若干 Descriptor。Characteristic 定义了数值和操作。把若干个相关的 Service 组合在一起，就成为了一个 Profile。</p><p><img src="/images/gatt_profiles.png" alt="gatt_profiles"></p><h4 id="BR-EDR-的-Profiles"><a href="#BR-EDR-的-Profiles" class="headerlink" title="BR / EDR 的 Profiles"></a>BR / EDR 的 Profiles</h4><p>虽然 BR / EDR 的配置文件都是在蓝牙2.0、 3.0 的时候设计的，但仍是目前蓝牙“大”流量数据传输的主要方式。比如硬件调试常用的串口通信（SPP），蓝牙耳机听歌用的 A2DP 协议，文件传输（FTP）等。</p><h5 id="SPP"><a href="#SPP" class="headerlink" title="SPP"></a>SPP</h5><p>Serial Port Profile，即串口配置文件，定义了使用蓝牙进行 RS232（或类似）串口仿真的协议和过程。这也是蓝牙诞生之初的主要功能：替代 RS232 有线通信，以无线的方式链接多个设备，克服同步问题。<br>SPP 协议栈示意图：<br><img src="/images/spp.png" alt="spp"><br>图源: <a href="https://www.bluetooth.org/docman/handlers/DownloadDoc.ashx?doc_id=260866&amp;vId=290097" target="_blank" rel="noopener">SIG - SPP_SPEC_V12</a></p><p>SPP 是基于 <a href="https://www.bluetooth.org/docman/handlers/DownloadDoc.ashx?doc_id=263754" target="_blank" rel="noopener">RFCOMM 通信协议</a>的规范，RFCOMM 是一种简单的传输协议，其实也是用于仿真RS-232（ITU-T V.24）串口通信。RFCOMM支持在两个设备之间模拟多个串口，或者在多个设备之间模拟串口，最多支持 两个设备间 60 个串口的同时连接。SPP 可以视为仅是对 RFCOMM的简单封装，Android 蓝牙 API 就将 RFCOMM 视为 SPP。</p><h5 id="A2DP"><a href="#A2DP" class="headerlink" title="A2DP"></a>A2DP</h5><p>官方描述：</p><blockquote><p>高级音频分发配置文件（A2DP）定义了在 ACL 通道上实现单声道或立体声高质量音频内容分配的协议和程序。典型的使用情况是将音乐内容从立体声音乐播放器流式传输到耳机或扬声器。音频数据以适当的格式压缩，以有效利用有限的带宽。环绕声分布不包含在此配置文件的范围内。</p></blockquote><p>上面提到的“适当的格式”也就是网上很多蓝牙音质讨论帖中提到的SBC、Aptx等编码格式。</p><p>此配置文件定义了以下角色：</p><ul><li><p>源 Source（SRC）</p><p>  传送数字音频流到微微网SNK端。</p></li><li>接收器 Sink（SNK）</li></ul><p><img src="/images/a2dp_roles.png" alt="a2dp_roles"><br>图源: <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=457083" target="_blank" rel="noopener">SIG - A2DP_SPEC_V132</a></p><hr><p>更多的 BR / EDR Profiles 和协议可以参考 <a href="https://www.bluetooth.com/specifications" target="_blank" rel="noopener">SIG官网</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols#Host_Controller_Interface_(HCI" target="_blank" rel="noopener">维基百科 - List of Bluetooth protocols</a>)</li><li><a href="https://www.bluetooth.com/specifications/bluetooth-core-specification" target="_blank" rel="noopener">SIG - Core Specification</a></li><li><a href="https://www.bluetooth.com/specifications/profiles-overview" target="_blank" rel="noopener">SIG - Traditional Profile Specifications</a></li><li><a href="https://www.bluetooth.com/specifications/protocol-specifications" target="_blank" rel="noopener">SIG - Protocol Specifications</a></li><li><a href="---title: Android 蓝牙开发 ᚼᛒ (一">Android docs - BluetoothSocket](https://developer.android.com/reference/android/bluetooth/BluetoothSocket)</a><br>date: 2018/11/18<br>comments: true<br>tags:</li><li>Android</li><li>Bluetooth</li></ul><hr><p>接触 Android 蓝牙开发已经有一段时间了，Android 官方文档虽然对蓝牙 API 介绍很详尽，但是对蓝牙协议不太了解的开发人员来说还是不足以建立一个系统的认识，当时和硬件组的小伙伴交流的时候这点带来的问题就特别明显。网上的资料少，并且良莠不齐，于是去 SIG 官网找了协议文档（七大卷，真的厚…)，查阅之后，厘清了很多概念，大致了解了整个系统轮廓。</p><p>接下来会从蓝牙协议和 Android 蓝牙开发这两部分来叙述。</p><p>这是第一篇，蓝牙协议。</p><h2 id="什么是蓝牙-1"><a href="#什么是蓝牙-1" class="headerlink" title="什么是蓝牙"></a>什么是蓝牙</h2><p>蓝牙是一种短距离的短波无线通信技术，目前主要分为<strong>基础率/增强数据率（BR / EDR</strong>）和<strong>低功耗（LE）</strong>两个版本，前者通常也称为<strong>经典版蓝牙</strong>。</p><p>关于蓝牙这个名称的由来，蓝牙的发展历史及各版本的比对等基本信息在<a href="https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99" target="_blank" rel="noopener">蓝牙的维基百科词条</a>上写得很详细，就不再赘述。</p><h2 id="蓝牙的架构-1"><a href="#蓝牙的架构-1" class="headerlink" title="蓝牙的架构"></a>蓝牙的架构</h2><p>蓝牙4.0是一个综合协议规范，它除了提出了新的 LE 规范，还囊括了 BR / EDR 规范，并在实际使用中分为了单模(Single mode)和双模(Dual mode)版本，前者仅支持 LE 规范且不能和蓝牙4.0之前的版本通信，后者同时支持 LE 和 BR / EDR 规范，并且兼容旧版蓝牙。</p><blockquote><p>本文关于蓝牙协议栈的分析均基于蓝牙4.1</p></blockquote><p>下图是根据蓝牙 4.1 核心技术栈及部分应用协议绘制的蓝牙协议栈示意图<br><img src="https://docs.google.com/drawings/d/e/2PACX-1vSPsBu4C99TXGRhrGDNB-XbGeaFb76966Zol_ZcCwRI0QUSI19fwi0GMbcLHMDLEMwKuBAXVUBtY3bP/pub?w=542&amp;h=510" alt="蓝牙协议栈"><br>*<em>上图仅供参考，详细架构图参见 <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=282159" target="_blank" rel="noopener">SIG 蓝牙协议文档</a></em><br><!-- more --></p><p>蓝牙协议栈主要由主机 (Host)、控制器(Controllers) 和主机控制器接口(Host Controller Interface, HCI) 三部分组成。</p><p>我们先以两个直观的表述来感受这三部分与我们现实设备的对应关系。</p><p><em>对于没有蓝牙的PC，我们通常可以淘宝买一个USB蓝牙适配器来为PC增加蓝牙功能</em>。这里的蓝牙适配器可以理解为Controllers，PC 可以理解为 Host，USB 的连接方式就是一种 HCI。</p><p>我们的手机上的蓝牙模块也可以这样对应，手机操作系统就是Host，Controllers就是主板上的蓝牙芯片，PCB 板上连接 CPU 和蓝牙 IC 的 <a href="https://zh.wikipedia.org/wiki/UART" target="_blank" rel="noopener">UART</a>，也是一种HCI。</p><p>当然，以上表述并不严谨，实际上 Host 层是硬件的抽象，而与具体的硬件无关，控制器是协议栈的底层实现，它才与硬件直接相关，通常就是蓝牙 IC。</p><p>前文图中展示的仅是一个通用的蓝牙架构图，我们手机上的双模蓝牙系统与之类似，但实际上<strong>一个蓝牙设备可以仅由一个 Host 和一个主控制器组成</strong>，HCI 层其实是可选的，在具有简单功能的蓝牙设备（例如耳机）中，Host 和控制器可以在同一微处理器上实现, 而无需 HCI。</p><p>主控制器可以是以下三种：</p><ul><li>BR / EDR 控制器</li><li>LE 控制器</li><li>BR / EDR 和 LE 组合控制器</li></ul><p>可选的还可以有一个或多个次要控制器(AMP)，AMP 在蓝牙 3.0 就已经引入，主要和 BR / EDR 搭配使用，作为数据高速传输通道。这种场景下，BR / EDR 主要用作搜索，配对，连接建立和连接维持的作用。当两个 BR / EDR 蓝牙设备 L2CAP 连接建立后，AMP 管理器能检测到另外一个设备的AMP管理器。当两个蓝牙设备都有 AMP 控制器，蓝牙核心系统提供这样一种机制，能让数据流从主控制器迁移到次要控制器，即通过 AMP 来传输，AMP 可以使用 <a href="https://zh.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="noopener">802.11</a> 协议转换层(PAL) 來提供更高的傳輸率，最高可达 54 Mbps。</p><p>结合以上，关于实际的蓝牙设备架构，我们可以组合几种控制器和 Host 得到以下符合规范的蓝牙架构：</p><ul><li>四种可能的单模架构</li></ul><p><img src="/images/single_arch.png" alt="single"></p><ul><li>三种可能的双模架构</li></ul><p><img src="/images/dual_arch.png" alt="dual"></p><p>控制器和 HCI 涉及底层硬件部分，不做更多讨论，接下来重点对 Host 层做一个具体的说明。</p><h2 id="Host-1"><a href="#Host-1" class="headerlink" title="Host"></a>Host</h2><p>Host 包含逻辑链路控制和适配层(Logical Link control &amp; Adaption Protocol, L2CAP) 以及图中未画出的 Channel Manager、Security Manager Protocol (SMP) 和图中出现的 GAP等其他更高层。L2CAP主要起到数据缓冲和简单数据管理的作用。通道管理器负责创建，管理和关闭用于传输服务协议和应用程序数据流的L2CAP通道。SMP等其他部分详情参见核心协议文档，我们把重点放到应用层。</p><h3 id="Profiles-1"><a href="#Profiles-1" class="headerlink" title="Profiles"></a>Profiles</h3><p>蓝牙系统中的应用程序互操作性（应用部分）由各种蓝牙配置文件（Profile）完成。</p><p> <strong>Profile 就是定义了一个实际的应用场景</strong>。具体来说，Profile 定义了蓝牙系统中从PHY（物理层）到 L2CAP 的每层以及核心规范之外的任何其他协议所需的功能和特性。应用的行为和数据格式也由 Profile 定义。当两个蓝牙设备都符合某一种配置文件 的所有要求时，即可开启并执行对应的应用操作。需要特别说明的是，LE 的Profile 和 BR / EDR 的并不兼容，前文中的蓝牙架构图里展示出的几个Profile例子中，<strong>蓝色背景的是 BR / EDR 特有的Profile</strong>。</p><p>蓝牙规范中定义了很多常用的 Profile，在 4.0 中引入的 GATT / ATT 让我们可以创建新的 Profile。 下面介绍一些常用的配置文件</p><h4 id="GAP-1"><a href="#GAP-1" class="headerlink" title="GAP"></a>GAP</h4><p><strong>GAP，即通用访问配置文件，所有蓝牙设备都必须实现的基本配置文件。</strong> 它定义了蓝牙设备的基本要求，例如，对于 BR / EDR，它定义了蓝牙设备以包括无线电，基带，链路管理器，L2CAP 和服务发现协议功能; 对于 LE，它定义了物理层，链路层，L2CAP，安全管理器，GATT / ATT。这将所有各层连接在一起，形成蓝牙设备的基本要求。它还描述了设备搜寻，连接建立，安全性，身份验证，关联模型和服务搜寻的行为方法。</p><ul><li><p>在BR / EDR中，GAP定义每个设备为单一角色，其可能具备的功能包括设备如何相互发现，建立连接以及描述用于身份验证的安全关联模型。设备可能只具备其中一种或多种功能，比如只具有启动或接受连接功能。</p></li><li><p>在 LE 中，GAP 定义了四个特定角色：<strong>Broadcaster</strong>，<strong>Observer</strong>，<strong>Peripheral</strong> 和 <strong>Central</strong>。如果底层 Controller 支持这些角色或角色组合，则设备也可同时支持多个角色。但是，在某一时刻只能支持其中一个角色。每个角色都指定了底层Controller的要求。这允许控制器针对特定用例进行优化。</p></li></ul><h4 id="LE-的-Profiles-1"><a href="#LE-的-Profiles-1" class="headerlink" title="LE 的 Profiles"></a>LE 的 Profiles</h4><p>如上所诉，LE 让我们可以创建自己的 Profile，当然需要遵循一定的规范，这个规范就是 GATT / ATT</p><h5 id="GATT-ATT-1"><a href="#GATT-ATT-1" class="headerlink" title="GATT / ATT"></a>GATT / ATT</h5><p>通用属性配置文件（GATT）构建在属性协议（ATT）之上，并为属性协议传输和存储的数据建立通用操作和框架。GATT 和 ATT 通常在 LE 中实现。</p><blockquote><p>是的，GATT 和 ATT 还可以在 BR / EDR 中实现，蓝牙 4.1 核心系统协议中对 GATT / ATT 的表述是：<em>“GATT和ATT不是特定于传输层的，其可用于BR / EDR 和 LE。而在 LE 中 GATT / ATT 用于搜寻服务，因此是必须实现的”</em> (<em>from</em> <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=282159" target="_blank" rel="noopener">core_SPEC_vol1_6.4</a>)</p></blockquote><p>GATT 定义了两个角色：服务端和客户端。 GATT 角色不一定与特定的 LE GAP 角色相关联，但可以由更高层的配置文件指定。GATT 服务器发送对请求的响应，并在配置时，在GATT服务器上发生指定事件时，向GATT客户端异步发送指示和通知。</p><p>GATT 按照层级定义了三个概念：服务（Service）、特征（Characteristic）和描述（Descriptor）。他们的包含关系如下图所示：一个 Service 包含若干个 Characteristic，一个 Characteristic 包含若干 Descriptor。Characteristic 定义了数值和操作。把若干个相关的 Service 组合在一起，就成为了一个 Profile。</p><p><img src="/images/gatt_profiles.png" alt="gatt_profiles"></p><h4 id="BR-EDR-的-Profiles-1"><a href="#BR-EDR-的-Profiles-1" class="headerlink" title="BR / EDR 的 Profiles"></a>BR / EDR 的 Profiles</h4><p>虽然 BR / EDR 的配置文件都是在蓝牙2.0、 3.0 的时候设计的，但仍是目前蓝牙“大”流量数据传输的主要方式。比如硬件调试常用的串口通信（SPP），蓝牙耳机听歌用的 A2DP 协议，文件传输（FTP）等。</p><h5 id="SPP-1"><a href="#SPP-1" class="headerlink" title="SPP"></a>SPP</h5><p>Serial Port Profile，即串口配置文件，定义了使用蓝牙进行 RS232（或类似）串口仿真的协议和过程。这也是蓝牙诞生之初的主要功能：替代 RS232 有线通信，以无线的方式链接多个设备，克服同步问题。<br>SPP 协议栈示意图：<br><img src="/images/spp.png" alt="spp"><br>图源: <a href="https://www.bluetooth.org/docman/handlers/DownloadDoc.ashx?doc_id=260866&amp;vId=290097" target="_blank" rel="noopener">SIG - SPP_SPEC_V12</a></p><p>SPP 是基于 <a href="https://www.bluetooth.org/docman/handlers/DownloadDoc.ashx?doc_id=263754" target="_blank" rel="noopener">RFCOMM 通信协议</a>的规范，RFCOMM 是一种简单的传输协议，其实也是用于仿真RS-232（ITU-T V.24）串口通信。RFCOMM支持在两个设备之间模拟多个串口，或者在多个设备之间模拟串口，最多支持 两个设备间 60 个串口的同时连接。SPP 可以视为仅是对 RFCOMM的简单封装，Android 蓝牙 API 就将 RFCOMM 视为 SPP。</p><h5 id="A2DP-1"><a href="#A2DP-1" class="headerlink" title="A2DP"></a>A2DP</h5><p>官方描述：</p><blockquote><p>高级音频分发配置文件（A2DP）定义了在 ACL 通道上实现单声道或立体声高质量音频内容分配的协议和程序。典型的使用情况是将音乐内容从立体声音乐播放器流式传输到耳机或扬声器。音频数据以适当的格式压缩，以有效利用有限的带宽。环绕声分布不包含在此配置文件的范围内。</p></blockquote><p>上面提到的“适当的格式”也就是网上很多蓝牙音质讨论帖中提到的SBC、Aptx等编码格式。</p><p>此配置文件定义了以下角色：</p><ul><li><p>源 Source（SRC）</p><p>  传送数字音频流到<a href="https://en.wikipedia.org/wiki/Piconet" target="_blank" rel="noopener">极微网</a> SNK 端。</p></li><li>接收器 Sink（SNK）</li></ul><p><img src="/images/a2dp_roles.png" alt="a2dp_roles"><br>图源: <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=457083" target="_blank" rel="noopener">SIG - A2DP_SPEC_V132</a></p><hr><p>更多的 BR / EDR Profiles 和协议可以参考 <a href="https://www.bluetooth.com/specifications" target="_blank" rel="noopener">SIG官网</a></p><h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://en.wikipedia.org/wiki/List_of_Bluetooth_protocols#Host_Controller_Interface_(HCI" target="_blank" rel="noopener">维基百科 - List of Bluetooth protocols</a>)</li><li><a href="https://www.bluetooth.com/specifications/bluetooth-core-specification" target="_blank" rel="noopener">SIG - Core Specification</a></li><li><a href="https://www.bluetooth.com/specifications/profiles-overview" target="_blank" rel="noopener">SIG - Traditional Profile Specifications</a></li><li><a href="https://www.bluetooth.com/specifications/protocol-specifications" target="_blank" rel="noopener">SIG - Protocol Specifications</a></li><li><a href="https://developer.android.com/reference/android/bluetooth/BluetoothSocket" target="_blank" rel="noopener">Android docs - BluetoothSocket</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触 Android 蓝牙开发已经有一段时间了，Android 官方文档虽然对蓝牙 API 介绍很详尽，但是对蓝牙协议不太了解的开发人员来说还是不足以建立一个系统的认识，当时和硬件组的小伙伴交流的时候这点带来的问题就特别明显。网上的资料少，并且良莠不齐，于是去 SIG 官网找了协议文档（七大卷，真的厚…)，查阅之后，厘清了很多概念，大致了解了整个系统轮廓。&lt;/p&gt;
&lt;p&gt;接下来会从蓝牙协议和 Android 蓝牙开发这两部分来叙述。&lt;/p&gt;
&lt;p&gt;这是第一篇，蓝牙协议。&lt;/p&gt;
&lt;h2 id=&quot;什么是蓝牙&quot;&gt;&lt;a href=&quot;#什么是蓝牙&quot; class=&quot;headerlink&quot; title=&quot;什么是蓝牙&quot;&gt;&lt;/a&gt;什么是蓝牙&lt;/h2&gt;&lt;p&gt;蓝牙是一种短距离的短波无线通信技术，目前主要分为&lt;strong&gt;基础率/增强数据率（BR / EDR&lt;/strong&gt;）和&lt;strong&gt;低功耗（LE）&lt;/strong&gt;两个版本，前者通常也称为&lt;strong&gt;经典版蓝牙&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;关于蓝牙这个名称的由来，蓝牙的发展历史及各版本的比对等基本信息在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%97%8D%E7%89%99&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蓝牙的维基百科词条&lt;/a&gt;上写得很详细，就不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;蓝牙的架构&quot;&gt;&lt;a href=&quot;#蓝牙的架构&quot; class=&quot;headerlink&quot; title=&quot;蓝牙的架构&quot;&gt;&lt;/a&gt;蓝牙的架构&lt;/h2&gt;&lt;p&gt;蓝牙4.0是一个综合协议规范，它除了提出了新的 LE 规范，还囊括了 BR / EDR 规范，并在实际使用中分为了单模(Single mode)和双模(Dual mode)版本，前者仅支持 LE 规范且不能和蓝牙4.0之前的版本通信，后者同时支持 LE 和 BR / EDR 规范，并且兼容旧版蓝牙。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文关于蓝牙协议栈的分析均基于蓝牙4.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图是根据蓝牙 4.1 核心技术栈及部分应用协议绘制的蓝牙协议栈示意图&lt;br&gt;&lt;img src=&quot;https://docs.google.com/drawings/d/e/2PACX-1vSPsBu4C99TXGRhrGDNB-XbGeaFb76966Zol_ZcCwRI0QUSI19fwi0GMbcLHMDLEMwKuBAXVUBtY3bP/pub?w=542&amp;amp;h=510&quot; alt=&quot;蓝牙协议栈&quot;&gt;&lt;br&gt;*&lt;em&gt;上图仅供参考，详细架构图参见 &lt;a href=&quot;https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=282159&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SIG 蓝牙协议文档&lt;/a&gt;&lt;/em&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Bluetooth" scheme="http://yoursite.com/tags/Bluetooth/"/>
    
  </entry>
  
  <entry>
    <title>关于 Java 多态（Polymorphism）</title>
    <link href="http://yoursite.com/2018/06/09/%E6%B7%B1%E5%85%A5%20Java%20%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/06/09/深入 Java 多态/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2019-02-24T16:55:40.012Z</updated>
    
    <content type="html"><![CDATA[<p>之前看 <em>Thinking in Java</em> 的时候自认为理解了 Java 中的多态性和方法动态绑定，直到看到下面这个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public String show(D obj) &#123;</span><br><span class="line">        return (&quot;A and D&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show(A obj) &#123;</span><br><span class="line">        return (&quot;A and A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public String show(B obj) &#123;</span><br><span class="line">        return (&quot;B and B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show(A obj) &#123;</span><br><span class="line">        return (&quot;B and A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123; &#125;</span><br><span class="line"></span><br><span class="line">class D extends B &#123; &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        A a1 = new A();</span><br><span class="line">        A a2 = new B();</span><br><span class="line">        B b = new B();</span><br><span class="line">        C c = new C();</span><br><span class="line">        D d = new D();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;1--&quot; + a1.show(b));</span><br><span class="line">        System.out.println(&quot;2--&quot; + a1.show(c));</span><br><span class="line">        System.out.println(&quot;3--&quot; + a1.show(d));</span><br><span class="line">        System.out.println(&quot;4--&quot; + a2.show(b));</span><br><span class="line">        System.out.println(&quot;5--&quot; + a2.show(c));</span><br><span class="line">        System.out.println(&quot;6--&quot; + a2.show(d));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 1--A and A</span><br><span class="line">     * 2--A and A</span><br><span class="line">     * 3--A and D</span><br><span class="line">     * 4--B and A</span><br><span class="line">     * 5--B and A</span><br><span class="line">     * 6--A and D</span><br><span class="line">     */</span><br></pre></td></tr></table></figure><p>最后的输出中，前三条是毫无疑问的，从第四条开始好像就不太符合我们直觉了，<code>a2</code>的实际类型是<code>B</code>, <code>a2.show(b)</code>调用的不应该是<code>B.show(B)</code>这个方法吗，为什么会调用<code>B.show(A)</code>方法呢？<br><a id="more"></a></p><p>这涉及到重载和重写在 JVM 中的实现，是 Java 多态性的基本体现。通过两个例子来分别说明：</p><h3 id="重载-Overload-–-重载解析-overload-resolution"><a href="#重载-Overload-–-重载解析-overload-resolution" class="headerlink" title="重载(Overload) – 重载解析 (overload resolution)"></a>重载(Overload) – 重载解析 (overload resolution)</h3><blockquote><p>在国内的文档中，这常被称为”静态分派”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bicycle 及其子类的源码在上面的栗子中可以找到</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BicycleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">(Bicycle b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bicycle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">(MountainBike b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MountainBike"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speed</span><span class="params">(RoadBike b)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"RoadBike"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bicycle bike01, bike02, bike03;</span><br><span class="line">        bike01 = <span class="keyword">new</span> Bicycle();</span><br><span class="line">        bike02 = <span class="keyword">new</span> MountainBike();</span><br><span class="line">        bike03 = <span class="keyword">new</span> RoadBike();</span><br><span class="line">        BicycleTest test = <span class="keyword">new</span> BicycleTest();</span><br><span class="line">        test.speed(bike01);</span><br><span class="line">        test.speed(bike02);</span><br><span class="line">        test.speed(bike03);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     * Bicycle</span></span><br><span class="line"><span class="comment">     * Bicycle</span></span><br><span class="line"><span class="comment">     * Bicycle</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><p>从运行结果可以看到，不论传入的参数的实际类型是什么，最终调用的都是参数类型为<code>Bicycle</code>的重载方法。</p><p>首先厘清两个概念：<strong>静态类型</strong>和<strong>实际类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bicycle bike02 = new MountainBike();</span><br></pre></td></tr></table></figure></p><p>其中，<code>Bicycle</code> 也就是我们前面提到的引用变量类型，称为变量的静态类型，或外观类型，<code>MountainBike</code>称为变量的实际类型。变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p><p>这种依赖静态类型来定位方法执行版本的动作称为静态分派，方法重载就是典型的静态分派，其选择方法的依据有两点：一是静态类型，二是方法参数（参数的类型也是依据静态类型）。</p><p>我们再看上面的例子，静态类型是确定的，因此使用哪个重载版本就完全取决于传入的参数类型是数量，而重载是通过参数的静态类型而不是实际类型作为判断依据的，因此在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了<code>speed(Bicycle)</code>作为调用目标，并把这个方法的符号引用写到<code>main()</code>方法里的两条<code>invokevirtual</code>指令的参数中。</p><p>实际上，由于自动转型的存在，在方法重载中，方法的参数类型不一定“完全匹配”，很多情况下编译器只能确定一个“最优”的版本，重载方法是存在匹配优先级的，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void hi(char c)&#123;</span><br><span class="line">     System.out.println(&quot;char&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> private void hi(int i)&#123;</span><br><span class="line">     System.out.println(&quot;int&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private void hi(Character C)&#123;</span><br><span class="line">     System.out.println(&quot;Character&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> private void hi(Integer I)&#123;</span><br><span class="line">     System.out.println(&quot;Integer&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>当我把<code>hi(char c)</code>注释后，调用的是<code>hi(int)</code>,把<code>hi(int)</code>注释后，调用的是<code>hi(Character)</code>…</p><p>自动转型的优先级：<code>char</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code> -&gt; <code>Character</code> -&gt; <code>Serializable/Comparable</code> -&gt; <code>Object</code> -&gt; 之前类型的 可变长参数类型</p><p>没有包含<code>short</code>，因为那是向下转型，不是自动转型；<code>Serializable/Comparable</code> 这两个是 <code>Character</code> 实现的接口，优先级高于父类。如果同时出现两个参数分别为<code>Serializable</code>和<code>Comparable＜Character＞</code>的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显式地指定字面量的静态类型，如：<code>hi((Serializable)&#39;c&#39;)</code>，才能编译通过。</p><h3 id="重写-Override-–-动态分派"><a href="#重写-Override-–-动态分派" class="headerlink" title="重写(Override) – 动态分派"></a>重写(Override) – 动态分派</h3><p>前面提到的，编译器是不知道实际类型的，因此重写的中方法确定发生在运行期。</p><p>运行阶段虚拟机的选择，也就是动态分派的过程。我们再看看文章开始举的例子，在执行<code>a2.show(b)</code>这句代码时，更准确地说，是在执行这句代码所对应的invokevirtual指令时，由于编译期已经根据静态类型(<code>A</code>) 和参数类型 (<code>A</code>) 决定目标方法的签名必须为<code>show(A)</code>，此时(运行期)方法参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是<code>A</code>还是<code>B</code>。<code>a1</code> 的实际类型是<code>B</code>，因此最终调用的是 <code>B</code> 的 <code>show(A)</code> 方法。</p><p>在动态分派中，因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型，而静态分派，如前所述，由两个宗量进行选择，属于多分派类型。</p><p>动态分派的过程优化是通过<a href="https://en.wikipedia.org/wiki/Virtual_method_table" target="_blank" rel="noopener">虚拟方法表(Virtual method table)</a>来进行的。</p><blockquote><p>重载是编译期进行的，也被称为<strong>编译器多态/静态绑定/早期绑定</strong>；重写属于<strong>动态绑定/运行期多态/后期绑定</strong>。<br><br>不能独立地看待多态，如果没有封装和继承的特性，就无法理解多态，其作为类关系“全景”中的一部分与其他特性协同工作。</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12" target="_blank" rel="noopener">Java语言规范 - Method Invocation Expressions</a></li><li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html" target="_blank" rel="noopener">Oracle Java Tutorials - Polymorphism</a></li><li><a href="https://dzone.com/articles/polymorphism-in-java" target="_blank" rel="noopener">Polymorphism in Java</a></li><li>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看 &lt;em&gt;Thinking in Java&lt;/em&gt; 的时候自认为理解了 Java 中的多态性和方法动态绑定，直到看到下面这个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String show(D obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (&amp;quot;A and D&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String show(A obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (&amp;quot;A and A&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class B extends A &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String show(B obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (&amp;quot;B and B&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String show(A obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (&amp;quot;B and A&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class C extends B &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class D extends B &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A a1 = new A();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        A a2 = new B();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        B b = new B();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        C c = new C();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        D d = new D();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;1--&amp;quot; + a1.show(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;2--&amp;quot; + a1.show(c));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;3--&amp;quot; + a1.show(d));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;4--&amp;quot; + a2.show(b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;5--&amp;quot; + a2.show(c));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;6--&amp;quot; + a2.show(d));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 1--A and A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 2--A and A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 3--A and D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 4--B and A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 5--B and A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 6--A and D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后的输出中，前三条是毫无疑问的，从第四条开始好像就不太符合我们直觉了，&lt;code&gt;a2&lt;/code&gt;的实际类型是&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;a2.show(b)&lt;/code&gt;调用的不应该是&lt;code&gt;B.show(B)&lt;/code&gt;这个方法吗，为什么会调用&lt;code&gt;B.show(A)&lt;/code&gt;方法呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/10/03/Hello%20World/"/>
    <id>http://yoursite.com/2017/10/03/Hello World/</id>
    <published>2017-10-02T16:00:00.000Z</published>
    <updated>2019-02-24T14:46:33.166Z</updated>
    
    <content type="html"><![CDATA[<p>Hello World !</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello World !&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Hello" scheme="http://yoursite.com/tags/Hello/"/>
    
  </entry>
  
</feed>
