<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eden</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-12T06:16:26.268Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Xio</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python IO - 输出重定向</title>
    <link href="http://yoursite.com/2019/02/12/Python%20IO%20-%20%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://yoursite.com/2019/02/12/Python IO - 输出重定向/</id>
    <published>2019-02-11T16:00:00.000Z</published>
    <updated>2019-02-12T06:16:26.268Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写Python单元测试的时候需要获取到待测试方法的<code>print()</code>输出，在<code>Shell</code>中使用管道重定向输出很容易，但是在<code>Python</code>中如何进行呢？</p><a id="more"></a><h1 id="Python-中的标准输入输出"><a href="#Python-中的标准输入输出" class="headerlink" title="Python 中的标准输入输出"></a>Python 中的标准输入输出</h1><h2 id="print-和-sys-stdout"><a href="#print-和-sys-stdout" class="headerlink" title="print 和 sys.stdout"></a>print 和 sys.stdout</h2><p>当我们在 Python 中打印值调用 <code>print(value)</code> 时候，等价于调用 <code>sys.stdout.write(value+&#39;\n&#39;)</code></p><p>print 将内容打印到了控制台，然后追加了一个换行符</p><h2 id="input-和-sys-stdin"><a href="#input-和-sys-stdin" class="headerlink" title="input 和 sys.stdin"></a>input 和 sys.stdin</h2><p>当我们用 raw_input(‘promption: ‘) 时，事实上是先把提示信息输出，然后捕获输入</p><p>以下两组在实际上等价：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hi=raw_input(&apos;Hi~&apos;)</span><br><span class="line"></span><br><span class="line">sys.stdout.write(&apos;Hi~&apos;)</span><br><span class="line"># -1 to discard the &apos;\n&apos; in input stream</span><br><span class="line">hi=sys.stdin.readline()[:-1]</span><br></pre></td></tr></table></figure></p><p>而在Python 3中新增的<code>input()</code>函数则在此基础上，增加了类型判断的处理，尝试将输入解析为适当的数据类型。</p><blockquote><p>实际上 print 或者 raw_input 在 cpython 中的源码要复杂得多，这里‘等价’的仅是示意其与标准输入输出直接相关。源码可以参考文末给出的链接</p></blockquote><h1 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h1><p>默认的 <code>sys.stdout</code> 指向控制台，我们可以重定向到其他流(或者具有<code>write</code>方法的对象)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#标准输出重定向至文件</span><br><span class="line">with open(&apos;out.txt&apos;, &apos;w+&apos;) as f:</span><br><span class="line">    sys.stdout = f </span><br><span class="line"></span><br><span class="line"># 标准输出重定向至字符流</span><br><span class="line">sys.stdout = strout = StringIO()</span><br></pre></td></tr></table></figure></p><p>完成任务后最好恢复标准输出至原先的地址(默认控制台)：</p><ul><li><p>可以在重定向前获取stdout的默认引用，恢复的时候再指向这个引用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">orig_stdout = sys.stdout</span><br><span class="line"># ...$重定向代码$...</span><br><span class="line"># ...print(&apos;hahaha...&apos;)...</span><br><span class="line"></span><br><span class="line"># 恢复</span><br><span class="line">sys.stdout = orig_stdout</span><br></pre></td></tr></table></figure></li><li><p>或使用<code>sys.__stdout__</code>，其保存程序开始时<code>sys.stdout</code>的原始值，且不受重定向影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ...$重定向代码$...</span><br><span class="line"># ...print(&apos;hahaha...&apos;)...</span><br><span class="line">sys.stdout = sys.__stdout__</span><br></pre></td></tr></table></figure></li></ul><p>结合上下文管理器，我们还可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def stdout_redirected(new_stdout):</span><br><span class="line">    save_stdout = sys.stdout</span><br><span class="line">    sys.stdout = new_stdout</span><br><span class="line">    try:</span><br><span class="line">        yield None</span><br><span class="line">    finally:</span><br><span class="line">        sys.stdout = save_stdout</span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">with opened(filename, &quot;w&quot;) as f:</span><br><span class="line">    with stdout_redirected(f):</span><br><span class="line">        print &quot;Hello world&quot;</span><br></pre></td></tr></table></figure></p><p>应用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from io import StringIO</span><br><span class="line"></span><br><span class="line"># parse 函数直接将&apos;解析&apos;结果打印出来了，我们需要判断解析是否正确</span><br><span class="line"></span><br><span class="line">def parse(query):</span><br><span class="line">    print(f&apos;query: &#123;query&#125;&apos;)</span><br><span class="line"></span><br><span class="line">def test(query):</span><br><span class="line">    sys.stdout = strdout = StringIO()</span><br><span class="line">    parse(query)</span><br><span class="line">    sys.stdout = sys.__stdout__</span><br><span class="line">    return strdout.getvalue()</span><br><span class="line"></span><br><span class="line">result = test(&apos;This message is for query&apos;)</span><br><span class="line">print(result.split()[1])</span><br><span class="line"></span><br><span class="line"># output：This</span><br></pre></td></tr></table></figure></p><p>同样的，<code>sys.stderr</code>, <code>sys.stdin</code> 也都可以被重定向到多个地址。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/python/cpython/blob/3.6/Python/sysmodule.c" target="_blank" rel="noopener">cpython 3.6 - sys</a></li><li><a href="https://github.com/python/cpython/blob/c41523ac2447b0e86b702f58458f3b3548439c8b/Python/bltinmodule.c#L1864" target="_blank" rel="noopener">cpython 3.6 - input</a></li><li><a href="https://docs.python.org/3/library/sys.html#sys.__stdout__" target="_blank" rel="noopener">python 3 doc - sys.__stdout__</a></li><li><a href="https://www.python.org/dev/peps/pep-0343/#use-cases" target="_blank" rel="noopener">PEP 343 – The “with” Statement use-case</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写Python单元测试的时候需要获取到待测试方法的&lt;code&gt;print()&lt;/code&gt;输出，在&lt;code&gt;Shell&lt;/code&gt;中使用管道重定向输出很容易，但是在&lt;code&gt;Python&lt;/code&gt;中如何进行呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="io" scheme="http://yoursite.com/categories/Python/io/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Android 构建脚本从Groovy迁移到Kotlin DSL</title>
    <link href="http://yoursite.com/2019/02/01/Android%20%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC%E4%BB%8EGroovy%E8%BF%81%E7%A7%BB%E5%88%B0Kotlin%20DSL/"/>
    <id>http://yoursite.com/2019/02/01/Android 构建脚本从Groovy迁移到Kotlin DSL/</id>
    <published>2019-01-31T16:00:00.000Z</published>
    <updated>2019-02-12T06:19:45.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kotlin-dsl-是什么？"><a href="#kotlin-dsl-是什么？" class="headerlink" title="kotlin-dsl 是什么？"></a>kotlin-dsl 是什么？</h1><h1 id="为什么要迁移？"><a href="#为什么要迁移？" class="headerlink" title="为什么要迁移？"></a>为什么要迁移？</h1><p>因为Groovy是动态语言，在用作Android构建脚本的时候，经常有些问题：</p><ul><li>很差的IDE支持(自动提示等)</li><li>性能问题</li><li>很多错误在<code>build</code>时才报出，而不是编译期</li><li>难以debug</li><li>重构很麻烦<br><br>…</li></ul><p>kotlin 并非动态语言，但却兼具了Groovy的灵活性和静态语言的特点，很大程度上解决了上面的问题。</p><p>所以，开始吧！！<br><a id="more"></a></p><h2 id="环境准备："><a href="#环境准备：" class="headerlink" title="环境准备："></a>环境准备：</h2><ul><li><p>升级 Gradle Wrapper 到5.0+</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># gradle-wrapper.properties</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-5.1-all.zip</span><br></pre></td></tr></table></figure></li><li><p>Gradle 5.0 只支持Java 8及以上，确保你的Java环境满足要求</p></li><li>升级所有的Gradle 插件</li></ul><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>Groovy和kotlin语言特性上的不同导致我们迁移时需要注意下面的不同：</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Groovy 中字符串单双引号都行，但是kotlin中字符串必须是双引号。所以<strong>第一步先把所有的<code>build.gradle</code>和<code>settings.gradle</code>里的<code>&#39;&#39;</code>全部替换为<code>&quot;&quot;</code></strong></p><h3 id="赋值-传值"><a href="#赋值-传值" class="headerlink" title="赋值/传值"></a>赋值/传值</h3><p>在Groovy中<code>xx yy</code>可以表示对变量<code>xx</code>赋与值<code>yy</code>，也可以表示调用函数<code>xx</code>，<code>yy</code>是参数，如Android中常见的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123; </span><br><span class="line">  // 赋值</span><br><span class="line">  versionName &quot;1.0&quot;</span><br><span class="line">  // 函数调用</span><br><span class="line">  minSdkVersion 16 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // 函数调用</span><br><span class="line">    api &apos;org.greenrobot:eventbus:3.1.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而在kotlin中则是和Java一样的语法，相应的，上面的栗子迁移后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    versionName = &quot;1.0&quot;</span><br><span class="line">    minSdkVersion(16)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api(&quot;org.greenrobot:eventbus:3.1.1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>知道了这个区别，但是很多<code>xx yy</code> 到底是赋值还是函数调用不好分辨，比如<code>minSdkVersion</code>居然是函数调用。可以利用AS的辅助功能，在kotlin-dsl 中是可以快速点选查看方法的源码的（mac 下 <code>cmd + click</code> ,Groovy不行）,而对属性变量就没啥反应，所以可以根据这个小trick来分辨。</p></blockquote><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task clean(type: Delete) &#123;</span><br><span class="line">    delete rootProject.buildDir</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.register(&quot;clean&quot;, Delete::class) &#123;</span><br><span class="line">    delete(rootProject.buildDir)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h1><ol><li>字符串单引号变双引号</li><li>重命名所有<code>xx.gradle</code>脚本文件，加上<code>.kts</code>后缀</li><li>插件声明<br><br>DSL的目标是尽可能具有声明性。 Kotlin DSL 使用<code>plugins</code>代码块来生成静态扩展函数以利用这些插件。因此，我们需要将之前Groovy中所有<code>apply plugin xxx</code> 移动到一个<code>plugins</code>代码块中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Groovy</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line">apply plugin: &apos;kotlin-kapt&apos;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Kotlin-dsl</span><br><span class="line">plugins &#123;</span><br><span class="line">    id(&quot;com.android.application&quot;)</span><br><span class="line">    kotlin(&quot;android&quot;)</span><br><span class="line">    kotlin(&quot;android.extensions&quot;)</span><br><span class="line">    kotlin(&quot;kapt&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>id()</code>是应用插件的标准方法，<code>kotlin()</code>是应用<code>Kotlin</code>插件的方法，我们查看源码可以发现，它只是封装了一下<code>id()</code>方法，省略了<code>org.jetbrains.kotlin.</code>:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun PluginDependenciesSpec.kotlin(module: String): PluginDependencySpec =</span><br><span class="line">   id(&quot;org.jetbrains.kotlin.$module&quot;)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>按之前提到的<a href="#基本原则">基本原则</a>改写所有语句</li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><ul><li><p>应用其他的<code>gradle</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//groovy</span><br><span class="line">apply from: &apos;custom.gradle&apos;</span><br><span class="line"></span><br><span class="line">// kotlin-dsl</span><br><span class="line">apply(from = &quot;custom.gradle&quot;)</span><br></pre></td></tr></table></figure></li><li><p>fileTree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>在kotlin-dsl中：<code>fileTree(Map&lt;String, ?&gt; args)</code>，因此我们需要传入的是Map：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(fileTree(mapOf(&quot;include&quot; to listOf(&quot;*.jar&quot;), &quot;dir&quot; to &quot;libs&quot;)))</span><br></pre></td></tr></table></figure></p><ul><li>signingConfigs</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><p><a href="http://groovy-lang.org/syntax.html#all-strings" target="_blank" rel="noopener">Apache Groovy - 字符串表示</a></p><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1></li><li><p>关于依赖</p></li></ul><p>groovy：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.jakewharton:butterknife:8.8.1&apos;</span><br></pre></td></tr></table></figure></p><p>kotlin:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(&quot;com.jakewharton:butterknife:8.8.1&quot;)</span><br></pre></td></tr></table></figure></p><p>上面是最基本的情况，我们查看kotlin dsl  implementation的源码可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun DependencyHandler.`implementation`(dependencyNotation: Any)...</span><br><span class="line"></span><br><span class="line">fun DependencyHandler.`implementation`(</span><br><span class="line">    dependencyNotation: String,</span><br><span class="line">    dependencyConfiguration: Action&lt;ExternalModuleDependency&gt;</span><br><span class="line">)...</span><br><span class="line"></span><br><span class="line">fun DependencyHandler.`implementation`(</span><br><span class="line">    group: String,</span><br><span class="line">    name: String,</span><br><span class="line">    version: String? = null,</span><br><span class="line">    configuration: String? = null,</span><br><span class="line">    classifier: String? = null,</span><br><span class="line">    ext: String? = null,</span><br><span class="line">    dependencyConfiguration: Action&lt;ExternalModuleDependency&gt;? = null</span><br><span class="line">)...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在这个<code>dependencies</code>的scope中，有非常多的implementation重载方法，可以用来处理：</p><ul><li><p>dependencyNotation:<strong>Any</strong><br><br>上面最基本的地址依赖就属于这种，还可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// groovy:implementation project(&apos;:library&apos;)</span><br><span class="line">implementation(project(&quot;:library&quot;))</span><br><span class="line">// groovy:implementation fileTree(include: &apos;*.jar&apos;, dir: &apos;libs&apos;)</span><br><span class="line">implementation(fileTree(mapOf(&quot;include&quot; to listOf(&quot;*.jar&quot;), &quot;dir&quot; to &quot;libs&quot;)))</span><br></pre></td></tr></table></figure></li><li><p>特别类型库依赖</p></li></ul><p>之前在<code>groovy</code>中添加特别类型库依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(name: &apos;c208blelibrary-release&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure></p><p>在<code>kotlin-dsl</code>中只能这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation (group=&quot;&quot;,name=&quot;c208blelibrary-release&quot;,ext = &quot;aar&quot;)</span><br></pre></td></tr></table></figure></p><p>必须加一个<code>group</code>还是很奇怪的，而目前看来这是一个bug(<a href="https://github.com/gradle/kotlin-dsl/issues/863" target="_blank" rel="noopener">Gitub issue</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kotlin-dsl-是什么？&quot;&gt;&lt;a href=&quot;#kotlin-dsl-是什么？&quot; class=&quot;headerlink&quot; title=&quot;kotlin-dsl 是什么？&quot;&gt;&lt;/a&gt;kotlin-dsl 是什么？&lt;/h1&gt;&lt;h1 id=&quot;为什么要迁移？&quot;&gt;&lt;a href=&quot;#为什么要迁移？&quot; class=&quot;headerlink&quot; title=&quot;为什么要迁移？&quot;&gt;&lt;/a&gt;为什么要迁移？&lt;/h1&gt;&lt;p&gt;因为Groovy是动态语言，在用作Android构建脚本的时候，经常有些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;很差的IDE支持(自动提示等)&lt;/li&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;很多错误在&lt;code&gt;build&lt;/code&gt;时才报出，而不是编译期&lt;/li&gt;
&lt;li&gt;难以debug&lt;/li&gt;
&lt;li&gt;重构很麻烦&lt;br&gt;&lt;br&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kotlin 并非动态语言，但却兼具了Groovy的灵活性和静态语言的特点，很大程度上解决了上面的问题。&lt;/p&gt;
&lt;p&gt;所以，开始吧！！&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
</feed>
